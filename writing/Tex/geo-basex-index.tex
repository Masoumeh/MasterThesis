Spatial index in BaseX is added both in baseX core and also BaseX-API packages. The main structure of the index is added as a package in core, defining the index builder classes, based on the core structure of BaseX. The class “SpatialBuilder” extends “IndexBuilder” and builds the index tree using pre-values of the nodes and serializes it into the disk, using JTS serializer. In the end, a file called “STRTreeIndex” for the related database is created. 
The other GeoIndex class in BaseX-API extends QueryModule and implements the methods defined by JTS STRTree class for reading the index file from hard disk into memory and filtering. These functions could be combined with regular geo functions, when spatial index is created for a database, to have the benefit of filtering feature and gain better performance. The below example clarifies how the indexing function should be used,
\begin{verbatim}
import module namespace geo-index = "http://expath.org/ns/GeoIndex";
import module namespace geo = "http://expath.org/ns/Geo";
declare namespace gml="http://www.opengis.net/gml";
let $a:= <gml:Polygon>
              <gml:outerBoundaryIs>
                	<gml:LinearRing> 
			<gml:coordinates>3.9,50.6 6,52.8 4.5,52.8 3.9,50.6</gml:coordinates> 
		</gml:LinearRing>
              </gml:outerBoundaryIs>
            </gml:Polygon>
return ( geo-index:filter("DB", $a)[geo:intersects( $a, .)])
\end{verbatim}
As it could be seen in this sample, first the filter function from the “GeoIndex” class does the first  filtering step and then the selected geometries are send to the intersects function to be checked against the intersection with the polygon a.  
Two approach of index function implementation : different module for indexing and implicit indexing, using Map → better perrformance in the second one  ??????????????

Time Complexity Issues

There is no need to emphasize on the importance of the role that indexing plays in query time and performance improvement. Here, we use real-world data to observe the effect of the implemented spatial index, followed by in depth looking at the implementation from other perspectives, trying to achieve better performance. This data is provided by University of Twente, Dept of Geoinformation Processing [] and holds some real information of geometries on earth, in GML 2.0 format. The original file based on one of the Netherlands' coordinate system (RD/NAP Amersfoort RD New) is around 133.3 MB and have 12773 polygons inside 11886 multi-polygons.
We run different queries on this database with and without spatial index to see time consumption dependency on the index structure. Moreover, queries have various number of results, to see also the trend changes concerning the number of outputs.
To start with, we take a look at the effect on index utilization in queries in comparison with queries using no spatial index. Figure … shows the effectiveness of index utilization.

(Figure index efficiency)

As it can be seen in this Figure, the query time when spatial index is not used, is fixed for different number of results. It means, it dose not have any relation with the output size and no matter how big the result is, it will remain fixed. As mentioned before, this is because of the fact that for each query, the whole file is scanned and analyzed. In contrast, queries using spatial index relatively take more time as the number of output objects goes higher. It confirms that filtering approach are going in the right direction, but the performance still is not satisfying. Thus, we need to investigate more ways to improve it.
By monitoring the times consuming by different part of a query, we discovered that JTS GMLReader functions also takes considerable amount of time (see Figure ….). It should be mentioned that up to this point JTS GMLReader class is being used to read and parse the geometries from GML and convert them to JTS geometries.  

(make a chart to show the bigness of the reader time)

Regarding the geometry reading process in JTS, shown in Figure …., it seemed that direct parsing approach might declines the query time. Thus, we implemented a custom GML reader class to immediately pars the gml elements into JTS geometries. As it was supposed, reading time dramatically reduced with the new functions. Figure … represents this time difference.

 (Fig. JTS reader and custom reader comparison)

Since the performance needs to get better yet, a deeper look at the different part of a query will help to find the points to concentrate more. Suppose we run the query below, using spatial query,
\begin{verbatim}
let $a:= <gml:Polygon> … </gml:Polygon>
return ( geo-index:filter("DB", $a) [geo:intersects( . , $a)]
\end{verbatim}
The total query time will be divided into the following parts,
reading the input geometry
filtering the geometries bu filter function 
reading the filtered geometries from the database
apply intersect operation on each pair of input geometry and selected geometries.

To follow our aim in this stage, we examine each part separately. Figure … shows the time taken by the mentioned functions. It could be seen, that the biggest amount of time is still taken by reading process. Even the single reading of the input geometry seems to be expensive. Hence, the reading function should be examined more in detail.

(Fig. For different timing part in a query)

We examine java profiling to get more precise information. The first few methods in profile output with the highest percentage of time occupation, ordered from most-used to least-used, are listed in the following,
\begin{verbatim}
rank   	self  		accum   count   	method
   1 	6.95%  	6.95%      94  	org.basex.util.Token.split
   2  	5.33% 		12.28%     72 	org.expath.ns.GmlReader.createPolygon
   3  	4.59% 		16.86%     62  	org.basex.util.Token.split
   4  	4.22% 		21.08%     57  	org.basex.query.func.JavaModuleFunc.eval
   5  	3.55% 		24.63%     48  	org.expath.ns.Geo.geo
   6  	3.18% 		27.81%     43 	org.basex.util.Token.split
   7 	3.03% 		30.84%     41  	org.basex.util.Token.split
   8  	2.96% 		33.80%     40  	org.basex.util.Token.split
   9  	2.74% 		36.54%     37  	org.expath.ns.Geo.geo
\end{verbatim} 
 As the profile output indicates, the call for function “split” consumes greater amount of time. Besides, “createPolygon” and “geo” functions, all used in GmlReader class are expensive ones. Therefore, these functions should be focused in performance tuning, if this approach would be taken.....???











