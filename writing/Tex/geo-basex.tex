
Geo features in BaseX are implemented based on the EXPath Geo Module Specification [ref.]. The module comprises a set of functions, widely used in geographic and geometric analysis, such as intersection, within, distance, boundary, centroid, diference, union, and etc. The functions are implemented in Geo module, mainly added to the “basex-api” package in BaseX. In addition, spatial index structure is implemented in BaseX core. Geo module is an individual package with a set of classes as below,
Geo
GeoError
GeoTest
GmlReader
GeoIndex

Geo class is the main one, in which all geo spatial functions are defined and implemented and could be used in Xquery. GeoErrors defined error functions with related massages to be thrown. GeoTest class contains functions to test the module. Functions required to read the GML geometries as xml elements are implemented in GmlReader class.  GeoIndex class offers functions to use geo spatial index in geo functions and queries. Spatial indexing and related implementation details will be described in he next section. Here we explain general functionalities of this module.
The geometries supported in this module, based on GML 2.0 standard, are,
Point
LineString
Polygon
Multi.. ???

The geo functions in Geo.java class are the public ones, accessible from BaseX GUI, using some private functions of the class to read geometries or write them out into the GUI. Besides, each function uses corresponding function from JTS library[ref.] to do the required geometric operation and provide the geo spatial functionalities. Here we briefly explain the process when input geometries either from a variable or a database node is processed and the result is returned.
Let's start it with an example, asking for geometries (here just the polygons are mentioned) within a specified polygon (p). The query should be written using Xquery via BaseX GUI as follow,

\begin{verbatim}
let $p := 
<gml:Polygon>
  <gml:outerBoundaryIs>… </gml:outerBoundaryIs>
<gml:Polygon>
	
for $x in //gml:Polygon
  return if ( within($x, $p) ) then $x else ()
\end{verbatim}

Each geo spatial function has at least one geometry as an input, as function “within” above. As in the example, the $p variable is provided as a node and the $x variables are database nodes. To read the geometries as a node, when the geo function (within) is called, the private function “geo” first checks the element name to make sure that at least the node name is a valid geometry name. It means, if the element name is something out of the set of geometry names, the function would throw an error. 
Then, the gmlReader class is used to read and pars the element and to check their validity based on GML2.0 format. The reader is implemented as the class “GMLReader” and differently reads the elements based on their types (tag names). If the element is a valid GML geometry, the function create the corresponding geometry, using JTS constructors. Otherwise, an appropriate error massage will be thrown. For instance, if a polygon does not have any outer ring or the coordinates of a geometry are not valid coordinates. 

(Figure for this process)

Now, the geometry is ready to be input for an geometric operation. For example, to check two geometries whether they intersect each other, the symmetric distance of two geometries, and number of inner rings of a polygon. The operation is done using the JTS function. The results could be numbers, boolean values, geometries, string, and few other data types. In case which the output is geometry, it needs to be converted to a database node (DBNode). Therefore, first JTS gml writer class is used to convert the GML format of the geometry to string. Next, the string, is used to create database instance to form a database node. Finally, the output is shown on GUI. This steps are shown in Figure ….
